## Side Effect

- 렌더링과 직접적인 관련이 없는 코드들
	- 컴포넌트 함수의 JSX Return 과 직접적으로 관련되지 않은 코드들
	- ex) 백엔드 API 호출
- 이런 코드들은 실행 시점을 컨트롤 해야 함
	- 만약 `useState()` 를 이용해서 이런 코드들을 제어하려고 하면 무한루프에 빠질 수 있음.
	- 상태 변경으로 인한 계속 컴포넌트 함수의 재호출이 발생하기 때문에
- 따라서 **`useEffect()`** 를 이용해야 함.
- 하지만 꼭 useEffect()가 필요한 건 아님.
	- 예를들어 매 렌더링시 호출되는 SideEffect가 아니라, 사용자 이벤트에 따라서 호출되는 SideEffect라면 무한 루프에 빠지지 않음.
		- ex) 버튼 클릭시 상태 변경 후 localStorage 저장.
	- 동기적이고 빠른 연산은 useEffect로 감쌀 필요가 없음.
		- ex) 브라우저의 LocalStorage 데이터 로드 (컴포넌트 함수 밖에 쓰는것이 효율적)

## UseEffect

- **실행 시점**
	- **컴포넌트 함수의 모든 렌더링이 다 마치고, DOM에 반영된 후  실행됨.**
- 의존성 배열
	- 어떤 값이 바뀌었을 때, useEffect가 다시 실행 되어야 한다면 해당 prop이나 state를 의존성 배열에 넣는다.
- 이용 사례
	- 백엔드 API 호출
	- 모달창을 선언적으로 관리할 때
	- 컴포넌트가 닫히기전 CleanUp해야하는 상황이 있을 때
- 주의사항
	- useEffect가 함수에 의존하고 있다면 useCallback을 사용해야 할 수 있음.
		- 리액트 컴포넌트 함수가 재실행될 때, 함수의 레퍼런스가 바뀐다는 것에 유의 
- CleanUp
	- useEffect 의 return 으로 반환하는 함수는 다음 두 가지 경우에 실행됨. 
		- useEffect를 다시 실행하기 전
		- 컴포넌트가 DOM에서 언마운트 되기 전


### UseCallback

- 컴포넌트 함수 재실행에 의한 함수 재생성을 막기위해 사용함
	- useEffect, React.memo 등과 함께 쓰임