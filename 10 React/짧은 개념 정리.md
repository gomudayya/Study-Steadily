
### Callback 함수

- 다른 함수에 인자로 전달되어, 특정 시점이나 조건에서 호출되는 함수

### Spread 와 Rest

- Spread 배열이나 객체에 있는 걸 펼쳐서 늘어놓기
- Rest 배열로 모으기. 함수 매개변수에서 사용

### 리액트는 명령형이 아니라 선언형

- UI 변동이 있을 때 명령 하는 것이 아니라, 어떤 UI여야 하는지 선언한다.

### JSX

- JavaScript 확장 문법으로, JS파일 안에서 HTML처럼 태그를 작성할 수 있게 해줌.

### Dynamic-Value 

- {} 를 사용해서 javascript expression 사용 가능

### Copmonent

- UI를 구성하는 독립적인 재사용 가능한 코드 블록.
- 보통 파일 하나에 하나의 컴포넌트 사용함. 재사용이 안되더라도 그렇게 구성 하는 듯
### Props

- 컴포넌트에 전달하는 데이터. 
- 이벤트 핸들링 용으로 함수를 넘길 수도 있음.
- 커스텀 인자를 넘기려면 화살표 함수를 사용
- Prop이 많으면 객체로 만들고 Destructuring 하면 깔끔함.

### 상태 

- useState 를 사용해서 관리 (리액트 훅이라고 한다)
	- useState는 배열에 상태 값과 상태 변경 함수를 담아서 반환함. 
	- 항상 컴포넌트 함수 최상단에 Pure하게 작성해야만 한다. (IF문 FOR문안에서 사용 불가)
- 상태가 변경되면 자손 컴포넌트 함수를 다시 실행함.
	- 상태 변경 직후에 바로 바뀐 값을 볼 수 없음.
- 이전 상태를 기반으로 해서 상태를 변경할 때는 화살표 함수를 사용한다
	- 이렇게 해야 항상 최신값을 보장받을 수 있다.
	- 리액트는 즉각적으로 상태를 바꾸는것이 아니라, 스케줄링하기 때문이다.
	- 

### 상태관리 철학

- 중복된 state를 없애고, derived state를 활용하자
- 

### Fragments

- JSX 표현 식은 항상 하나의 값을 반환해야 한다. 
	- 함수의 값이기 때문에
- 따라서 Sibling Elemetns는 허락되지 않고, One Root로 구성해야한다.
- One Root로 구성하게 해주는게 Fragment 이다.

### Props Forward Pattern

- props를 내부 컴포넌트에 있는 그래도 전달
- spread와 rest연산자를 활용해서 넘김

### Wrapper Component

- 틀? 껍데기? 느낌의 컴포넌트. 서식을 재사용할 때

### Refs

- JSX 요소에 접근할 수 있음
- 컴포넌트 함수를 재 실행하지 않음 (state와 비교했을 때)
- 하지만 컴포넌트 함수가 재실행 될 때에 Refs값은 유실되지 않음

### Props Drilling 

- 여러층의 자식 컴포넌트를 거치면서 prop을 전달하는 상황
- 계층구조가 깊어지면서, 중간에 있는 컴포넌트들은 단순히 prop을 전달하기 위해 prop을 갖게 됨.

### UseEffect

- `useEffect`는 컴포넌트가 렌더링된 후 특정 작업을 실행하도록 하는 훅이다.
- 두 번째 인자인 의존성 배열에 따라 실행 시점과 횟수를 제어할 수 있다.

| 코드                                 | 실행 타이밍                       | 실행 횟수     |
| ---------------------------------- | ---------------------------- | --------- |
| `useEffect(() => { ... }, [])`     | **처음 마운트 시**                 | 딱 **1번만** |
| `useEffect(() => { ... }, [a, b])` | **첫 마운트** + `a`나 `b`가 바뀔 때마다 | 여러 번      |
| `useEffect(() => { ... })`         | **모든 렌더링마다**                 | 무조건 매번    |
- useEffect는 렌더링 완료 후 실행 된다. 이 부분이 컴포넌트 함수 본체에 작성하는 것과 구별된다.
- **useEffect의 return 으로 들어오는 함수는 언마운트 될 때 호출되는 Clean-Up 함수이다**
- useEffect 안의 콜백함수가 의존하고 있는 변수, 함수, 객체가 있을 때, 해당 대상이 변경될 가능성이 극히 낮더라도, DependancyArray에 넣어주는 것이 관례이다.

### React Context API


### Reducer


### StrictMode

- 모든 컴포넌트 함수가 두 번 실행됨
	- 컴포넌트 함수가 한 번 실행되든 두 번 실행되든 리액트는 항상 같은 동작을 해야함.
	- 따라서 다른 동작을 하게 된다면 버그를 의심할 수 있음.

### Memo

- 컴포넌트를 메모이제이션 해놓고, prop이 변동되지 않으면 메모이제이션 된 컴포넌트를 사용함.
- 가능하면 컴포넌트 트리 상단에 거는 것이 좋다.
	- 상위 컴포넌트가 메모된 컴포넌트를 재활용 하면, 하위 컴포넌트도 재렌더링 되지 않는다.
- Prop 변경이 너무 잦으면 안 쓰는 것이 좋다.
- Memo 도 결국 메모이제이션 하는데, 메모리를 사용하기 때문에 트레이드 오프가 있다.\

### useEffect, JSX순수함수

- 리액트의 각 컴포넌트는 순수함수를 유지하는 것이 리액트의 철학이다.
- 순수함수는 입력이 있을 때 항상 같은 값이 나오는 것을 말한다.
- 그런데 DB데이터나 서버데이터와 같이 외부의 데이터가 끼어들면, 순수 함수를 지키지 못한다.
- 이런 경우에 useEffect 훅을 사용한다. useEffect 훅은 부수 효과를 일으킨다. 
- 하지만 useEffect는 모든 컴포넌트들이 다 렌더링이 된 이후에 실행되기 때문에 JSX함수 자체는 순수함수를 유지한다.

### 클로저 트랩

  - 리액트는 상태값 변경시 컴포넌트 함수를 재렌더링한다.
  - 이 때, 각 함수들도 새로 작성되면서, 최신의 상태값을 사용한다.
	(클로저 문제가 발생하지 않음)
  - useEffect 콜백도 매 렌더링마다 새로 작성된다.
  - 하지만 실행 여부는 dependency array에 따라 결정된다.
  - 특히 []인 경우에는 첫번째 렌더링에 작성된 콜백만 실행되니 조심하자.
    - 이후 렌더링에서도 새 콜백이 작성되지만 실행되지 않고 버려짐
    - 처음 실행된 콜백 안의 비동기 작업(setInterval 등)이 오래된 클로저를 참조함
-  dependancy array에 state값을 설정하거나, 화살표 함수를 사용해서 해결할 수 있다.

