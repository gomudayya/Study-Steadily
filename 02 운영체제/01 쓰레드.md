
- 운영체제 쓰레드
	- 라이프사이클
	- 스케줄링
	- 컨텍스트스위칭
	- 계층간 맵핑
	- 물리적 코어
	- 하이퍼쓰레딩
- JVM 스레드와 OS스레드의 관계
	- 버츄얼쓰레드
---

**쓰레드는 CPU 이용의 기본 단위이다.** 

```
새 프로세스가 해야 할 일이 기존 프로세스가 하는 일과 동일하다면 많은 오버헤드를 감수할 필요가 있을까? 그것 보다는 프로세스 안에 여러 스레드를 만들어 나가는 것이 더 효율적이다.
```

### 쓰레드 API

- Pthread (POSIX Thread) 
	- 유닉스 계열 OS 에서 사용하는 표준 API
	- POSIX 명세를 따르는 라이브러리 (OS마다 구현체는 다름)
- Windows Thread API
	- 윈도우 OS 에서 사용

위의 두 라이브러리를 사용해서 사용자 영역에서 커널 쓰레드를 제어할 수 있다. 

### 쓰레드의 구조 및 개념

![[Pasted image 20260104100447.png]]

**[ 쓰레드 ]**

- 커널 쓰레드는 Light Weight Process (LWP) 라고도 부른다.
- 프로세서 활용의 기본 단위
- **제어요소** 외의 자원들은 프로세스의 다른 스레드들과 공유
	- 쓰레드는 프로그램 실행 및 제어에 초점이 맞춰져 있음
- 아래의 생명주기를 거친다
	- New(생성), 준비(Ready), 실행(Running), 대기/블록(Waiting,Blocked), 종료(Terminated)


**[ 다중 쓰레드 사용의 장점 ]**

- 응답성
	- 한 스레드가 블락되어도 다른 스레드는 계속 실행
- 자원공유
	- 프로세스안의 스레드끼리는 코드와 데이터를 공유한다. 
	- 공유 메모리와 메시지 전달을 하는 프로세스간 자원공유에 비하면 훨씬 간단하다.
- 경제성
	- 프로세스에 비해 생성 오버헤드가 훨씬 적다. 자원을 공유하기 때문에
	- 컨텍스트 스위칭 비용이 적다.
		- 페이지 테이블 전환 X
- 규모적응성
	- 다중코어 시스템을 더 잘 활용할 수 있음
	- 병렬처리 가능
		- 단일코어에서 스레드가 인터리브되는 것은 병행성을 제공할 뿐, 병렬성은 아니다.

### 컨텍스트 스위칭 (문맥교환)

CPU가 실행중인 스레드를 변경(T1->T2)할 때, 
스레드의 실행 상태를 저장(T1)하고 복원(T2)하는 것

```
 쓰레드 간의 문맥 교환은 T1이 사용하던 레지스터들을 저장하고 T2가 사용하던 레지스터의 내용으로 복원한다는 점에서 프로세스의 문맥 교환과 유사하다. 프로세스가 문맥 교환을 할 때에 프로세스의 상태를 프로세스 제어 블럭(process control block, PCB)에 저장하듯이 프로세스의 쓰레드들의 상태를 저장하기 위해서는 하나 또는 그 이상의 쓰레드 제어 블럭(thread control block, TCB)이 필요하다. 가장 큰 차이 중 하나는 프로세스의 경우와 달리 쓰레드 간의 문맥 교환에서는 주소 공간을 그대로 사용한다는 것이다 (사용하고 있던 페이지 테이블을 그대로 사용하면 된다).
```

### 쓰레드 모델

(사용자 영역 - 커널 영역)

- N : 1
	- 멀티코어의 이점을 살리지 못함. 사용 X


- N : M
	- 구현이 어렵다. 
	- 처리 코어 수가 증가하면서 커널 스레드를 제한하는 것의 중요성이 줄어들었다.
- 1 : 1
	- 대부분의 운영체제가 이 방식을 사용한다.

### 스케줄링

Ready 상태에 있는 쓰레드중 어떤 쓰레드에게 CPU를 할당할 것인가?
CPU를 계속 활용하게 할 것인가? 아니면 도중에 뺏어올 것인가 (선점, 비선점)

##### 스케줄링 정책

- **선점** (Preemptive, 차지하는)
	- 커널에 의해 자원(CPU)을 빼앗길 수 있음
		- 할당 시간 종료, 우선순위 높은 프로세스의 등장
	- 단점
		- 컨텍스트 스위칭 오버헤드가 큼
- 비선점 (Non-preemtive)
	- 할당 받은 자원을 반납할 때 까지 사용
	- 컨텍스트 스위칭 오버헤드가 적음
	- 단점 
		- 평균 응답시간 증가
		- 우선순위 역전


현대 스케줄링은 대부분 **선점형 정책**을 사용한다.
##### 스케줄링 알고리즘 성능 척도

**[ CPU 관점에서의 성능 척도 ]** 

- CPU 이용률
- 처리량
	- 단위 시간당 완료한 프로세스 수
	- 컨텍스트 스위칭이 잦아지면 처리량이 낮아질 수 있다.

**[ 프로세스 관점에서의 성능 척도 ]**

- 소요시간 (Turn Around Time)
	- Ready 큐에서 부터, 프로세스 종료까지의 시간
- 대기시간 (Waiting Time)
	- Ready 큐에서 대기한 총 시간
- 응답시간 (Response Time)
	- 프로세스가 처음으로 CPU에서 실행되기까지의 시간

### 스케줄링 알고리즘

- FCFS (First-Come First-Served)
- SJF (Shorest Job First)
	- FCFS보다 대기시간, 응답시간 관점에서 좋음
	- CPU BurstTime 예측을 어떻게 할 것인가? (과거 사용을 통한 추정치)
	- 기아상태 발생 가능 
- RR (Round Robin, 선점형)
	- 동일한 크기의 할당시간(Time Quanturm) 사용
	- 응답시간 관점에서 좋음. 
	- 기아상태 X 
	- 추정치를 사용하지 않음.
	- 할당시간을 적게 잡으면 Context Switching 비용이 커질수 있음
- HRRN (High-Response-Ratio-Next)
	- SPN + Aging 개념 사용
	- 기아상태 방지가능
- MLQ (Multi-Level Queue)
	- Ready Queue를 여러개로 분할하고, 우선순위에 따라 분류
		- system, interactive, interactive editing, batch, student (높음 -> 낮음)
	- 각 큐는 독립적인 스케줄링 알고리즘을 가짐
		- foreground - RR
		- background - FCFS
	- 큐에 대한 스케줄링이 필요
	- 최초 배정된 Queue를 벗어나지 못함
- MFQ (Multi-Level Feedback Queue)
	- Ready Queue를 여러개로 분할하되, Queue간의 이동을 허용함
	- Ready Queue마다 시간할당량을 다르게 배정
	- Ready Queue마다 우선순위가 존재(강등, 승격이 있음)
		- 할당시간을 다 쓰면 한 단계 아래큐로 강등
		- I/O가 많으면 상위큐로 승격 (응답시간 최소화)
		- 오래 대기시 상위큐로 승격


### JVM 쓰레드와 OS 쓰레드

- JVM 쓰레드는 기본적으로 OS 스레드와 1:1 매핑되어 동작한다.
	- 자바에서 쓰레드를 생성하고 .start()를 호출하면, JNI를 통해 커널 쓰레드를 생성한다.
	- 이 때, 현재 운영체제에 따라서 Pthread (UNIX 계열) 또는 Windows API 를 사용하여 커널 쓰레드를 생성한다.
	- 따라서 JVM 쓰레드는 결국 OS의 스케줄링 메커니즘에 의존한다.

- 과거 JDK 1.1의 그린쓰레드는 커널이 쓰레드의 존재를 모르는 완벽한 사용자레벨 쓰레드였다.
	- 사용자레벨에서 스케줄링을 한다.
	- 하지만 N:1 모델로 멀티코어 활용이 불가해서 폐기되었다.
		- 

- 버츄얼쓰레드 (JDK19도입, 명시적으로 사용해야 함)
	- Virtual Thread는 커널 쓰레드(1) : 플랫폼 쓰레드(1) : Virtual Thread(N)의 구조로 사용된다.
	- ![Screenshot 2024-02-04 at 2 52 58 PM](https://d2.naver.com/content/images/2024/03/0a710dbd-8c39-16f6-818e-1bd47330670c.png)

	- 커널쓰레드의 문맥교환보다, 유저 레벨에서 문맥교환이 (컨티뉴에이션) 훨씬 가볍다.
	- 커널쓰레드의 문맥교환은 CPU 레지스터를 전체를 저장/복원 하고, 시스템콜을 호출하는 등의 비용이 있다.
	- JVM내에서의 문백교환은 스택프레임에 대한 정보와 실행위치를 힙에 저장함으로써 이루어지고, 커널쓰레드의 문맥교환보다 가볍다.


기술



**시나리오, 비지니스**




