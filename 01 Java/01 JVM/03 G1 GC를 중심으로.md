
### 기본 용어 

- **Region**
	- G1 GC는 힙메모리를 동일한 크기의 독립된 여러 Region으로 구분한다.
	- 각 리전은 아래 역할중 하나의 역할을 가진다.
		- Free (빈상태, 아직 객체 할당 X, Freelist에서 관리한다.)
		- Eden 
		- Survivor
		- Old
		- Humongous 
			- 큰 객체를 저장한다. 보통 byte[] 또는 char[]
			- 리전 하나의 용량의 절반을 넘기면, 큰 객체이고 연속된 리전에 저장한다.
			- Old Generation으로 취급된다.


- **Freelist**
	- 사용 가능한 빈 region 목록
	- 객체 할당시 Freelist에서 빈 region 선택하고, Eden으로 지정한 후 할당한다.
	- 객체 회수시 Region을 비우고, Freelist에 반환한다.


- **G1 GC**, **Garbage First**
	- G1은 'Garbage First' 를 짧게 줄인 표현이다.
	- G1 GC는 모든 region을 회수하지 않고, 가장 회수 가치가 큰 Region을 먼저 회수한다.
	- 위와 같은 의미에서 Garbage First라고 한다.
		- 클래식 GC들은 신세대 전체, 혹은 구세대 전체, 혹은 힙 전체를 대상으로 회수 했다.
		- 따라서 힙 전체 메모리가 커지면, Pause Time 또한 매우 길어졌다.
	- G1 GC는 사용자가 설정한 Pause Time 안에 회수 가치가 큰 Region들을 우선적으로 회수한다. 이로 인해 사용자 스레드 정지시간을 예측 가능하게 하고, 짧게 가져갈 수 있다.


- **Cset, CS (Collection Set, 회수 집합)**
	- GC마다 새로 생성된다. 이번 GC에 회수할 것들을 선택한다.
	- G1 GC는 각 region의 회수 가치를 추적해서 CSet을 구성한다.
	- 회수 가치 = 회수 가능한 메모리 크기 / 예상 회수 시간 (경험값)


- **Rset, RS (Remembered Set, 기억 집합)**
	- 외부 Region에서 나를 가르키는 참조들의 목록. (위상정렬 InDegree 개념과 유사)
	- 클래식 GC에서는 세대간 참조를 다룰 때 Young 영역에 대한 RSet이 존재
		- Young GC를 할 때, 구 세대 객체를 전부 스캔하는것을 방지하기 위해
	- G1 GC에서는 모든 Region이 Rset을 가진다. 
		- Rset에 기록된 참조는 GC루트처럼 취급된다.


- **Write Barrier** **(쓰기 장벽)**
	- JVM이 사용자 프로그램이 돌아갈 때 실행하는 짧은 코드
	- object.field = reference 와 같은 형태의 코드(참조변경)가 실행 될 때, Write Barrier가 실행됨. (Low-Level의 AOP에 비유된다.)
	- 객체간 참조 변경을 추적하기위한 코드이다.
	- Rset을 업데이트하는데 활용하고, 뒤에 나오는 SATB나 증분업데이트에서도 활용된다.


- **루트노드 열거**
	- GC 시작 시 모든 GC Root를 찾아내는 과정
		- 스택의 지역변수, 혹은 클래스의 적정변수 등
	- 사용자 스레드를 반드시 중단시켜야 한다. (STW)


- **동시 표시, Concurrent Marking**
	- 사용자 스레드와 동시에 실행되며 생존 객체를 표시(Marking)하는 과정
	- 사용자 스레드 정지시간(Stop-The-World)을 최소한으로 줄이기 위해 사용한다.


- **Tri-Color Marking** **(삼색 마킹)**
	- 객체 그래프를 탐색 할 때, 흰색, 검은색, 회색 중 하나로 색칠하는 기법
	- 객체 그래프 탐색은 스택을 이용한 DFS알고리즘으로 이루어진다.
	- 흰색
		- 가비지 컬렉터가 방문한 적 없는 객체.
		- 처음에는 모든 객체가 흰색이며, 탐색이 마친 뒤에도 흰색이면 회수 대상이다.
	- 검은색
		- 가비지 컬렉터가 방문한 적이 있는 객체이다. 확실히 생존함을 의미한다.
		- 스택에서 꺼내어지고, 자신의 '직속 자식'까지 확인해서 스택에 넣으면 검정색으로 표시한다.
	- 회색
		- 아직 탐색이 진행중인 객체이다.
		- 이전 노드를 통해 방문은 한 번 했지만, 아직 스택 안에 있고, 꺼내지지 않은 객체

	- **삼색마킹의 문제점. 왜 SATB와 증분업데이트 같은 동기화 기법이 필요한가?**![](https://velog.velcdn.com/images%2Frecordsbeat%2Fpost%2F91db1609-e9e8-462c-8495-a13ce2177d37%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-07-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.44.51.png)
	- 위의 그림은 ConcurrentMarking Phase를 삼색마킹으로 표현한 그림이다.
		- 빨간색 화살표는 사용자 스레드에 의해 객체 참조가 끊긴 부분이다.
		- 녹색 화살표는 사용자 스레드에 의해 객체 참조가 추가된 부분이다.
	- 문제
		- 5시 방향의 흰색 노드는 사용자 스레드에 의해 객체 참조가 끊겨 마킹이 될 수 없다.
		- 그런데 이미 마킹이 완료된 검정 객체에 의해 객체참조가 추가되었다.
		- 현재 마킹상태만 보면 흰색 노드 2개는 회수 대상이다. 하지만 사용자 스레드에 의해 참조가 추가되었기 때문에 분명히 사용하는 객체이다.
		- 사용하는 객체를 회수하면 프로그램상의 매우 치명적인 문제가 발생하게 된다.
			- 사용하지 않는 객체를 회수하지 않는 것(Floating Garbage)은 어차피 다음 GC에서 회수되기 때문에 치명적이지 않다. 하지만 사용하는 객체를 회수하는 것은 절대 안된다.

	- 해결방안 (둘 중 하나만 사용해도 해결할 수 있다)
		- **SATB** (G1,셰넌도어)
		- **증분업데이트** (CMS)


- **SATB (Snapshot At The Beginning, 시작 단계 스냅숏)**
	- Concurrent Marking 기간 동안 '참조가 끊겼을 때' 끊긴 참조 정보를 기록한다. 
	- 참조의 변경을 추적할 때는 Write Barrier를 이용한다.
	- Concurrent Marking 이 종료되면 사용자 스레드를 중지시킨 후 참조가 끊겨서 탐색이 안되었던 부분을 마킹한다.
	- 참조가 끊긴 부분들이 다시 사용되지 않기 때문에 Floating Garbage가 많이 생길 수 있다.


- **증분 업데이트 (Incremental Update)**
	- Concurrent Marking 기간 동안 '참조가 추가되었을 때' 추가된 참조 정보를 기록한다.
		- 정확히 하면 검은색 노드에서 흰색 노드로의 참조 추가가 생길때이다.
	- SATB와 마찬가지로 Write Barrier를 이용한다.
	- Concurrent Marking 이 종료되면 사용자 스레드를 중지시킨 후 참조가 추가된 객체들을 마킹한다.
	- 검은색 노드에서 흰색노드로의 추가가 생길때 참조 정보를 기록하므로, 이 조건을 판단하는 로직때문에 Write Barrier 비용이 커질 수 있다.


- **TAMS**
	- Concurrent Marking 을 하는동안에도 Young 영역에서 승격해서 넘어오는 객체가 있을 수 있다.
	- 어디까지가 마킹 대상인지 구분이 필요하다.
	- TAMS가 그 경계를 표시한다.
		- 새로운 객체들은 TAMS 포인터보다 높은 주소 영역에 할당되고, 사용중이라고 간주한다. (추후 마킹한것과 동일하게 처리)


- **Safe Point (안전 지점? 안전 영역)**


---

### G1의 등장 배경

- 메모리 기술의 발전으로 인한 힙 사이즈의 증가
- 기존 GC로는 가비지 컬렉션 PauseTime이 매우 김
- 큰 사이즈의 힙(6GB+) 에서도 목표한 PauseTime을 만족하고, 예측가능하게 동작하는 GC를 목표로 만들어짐
- 메모리 단편화 문제도 더 잘 해결한다. CMS GC는 Concurrent Marking은 하지만 Compacting은 하지 않는다. 그래서 메모리 단편화 문제가 존재한다. 그래서 Full GC를 할 때에는 Compacting을 해주는 다른 클래식 GC를 사용하는 식으로 문제를 해결했었다. 하지만 G1 GC는 Region간 이주 방식으로 이런 문제를 원천적으로 해결해준다.
- G1은 JDK 7에서 정식 출시되고, JDK9부터는 기본 GC로 채택되었다. Oracle은 대부분의 상황에서 G1이 클래식 GC보다 우수하며, 클래식 GC가 더 나은 경우에도 그 차이는 미미하다고 한다.


**[ G1의 권장 사례 ]**

CMS 또는 ParallelOldGC를 사용하는 상황인데, 아래 경우중에 해당되는 것이 있으면 G1을 사용하는게 좋다.

- Full GC 기간이 매우 길거나, 빈번히 발생한다.
- 할당속도나 승격속도(세대간)이 크게 변동한다.
- 0.5초 이상의 원치않은 긴 가비지컬렉션 중지 시간

## G1의 동작 과정

G1 GC는 크게 **Young Only Phase**와 **Space Reclamation Phase** 두 단계가 교차하면서 진행된다. Space Reclamation 은 직역하면 공간회수 인데, 단어 자체에 집중하면 혼란스러울 수 있다. 왜냐하면 Young Only Phase도 공간 회수가 되는건 마찬가지이기 때문이다. 그래서 **Space Reclamation Phase는 Mixed GC를 통해 Young과 Old를 함께 수집하는 단계로 이해하는게 더 좋을 듯 하다.**

그리고 아래 그림을 보면 **Young Only Phase라고 순수하게 Young GC만 하는것은 아니다.** 아래의 그림 10시방향의 선을 기점으로 Concurrent Mark 과정이 시작된다. Concurrent Mark 과정은 애초에 그 목적이 Old Collection의 회수를 목적으로 하는 과정이다. 잇따르는 Reamrk와 Cleanup 과정도 그러하다. 따라서 Young-only Phase라고 해서 Young GC만 한다고 이해해서는 안된다.

  
![Description of Figure 7-2 follows](https://docs.oracle.com/en/java/javase/17/gctuning/img/jsgct_dt_001_grbgcltncyl.png "Description of Figure 7-2 follows")

- 원 : GC Pause를 의미. 
- 파란색 원 
	- Young-only collection 대상 회수. 
	- 작은 파란원은 순수한 Young GC이다.
	- 큰 원은 Young GC는 물론이고, Old영역 회수를 위한 Initial Marking 단계를 포함한다. Young GC를 할 때 '편승' 해서 이루어진다.
- 주황색 원 : Marking 관련 Pause
- 분홍색 원 : Mixed Collection 대상 회수

### 순수한 Young GC

위 그림의 작은 파란원에 해당하는 것이 순수한 Young GC이다. Young Region, 즉 Eden과 Survivor 영역을 대상으로 GC가 일어난다. 이 때는 반드시 유저스레드가 중단되는 Stop-The-World Pause가 발생하고, 이 Pause 기간동안 Young GC를 마치는 방식이다. 

유저 스레드의 실행을 멈추고, 루트노드를 열거한다. 그리고 Eden과 Survivor 영역의 객체들만 추적해서 도달가능성을 판단한다. 그리고 도달가능한 객체들은 비어있는 Survivor 영역으로 이주(Evacuation) 시키거나, 충분히 생존한 객체들은 Old 영역으로 승격시킨다. 그리고 이주가 완벽하게 이루어지면, Garbage 객체들이 남은 Eden과 Survivor 영역은 반납한다.

이 순수한 Young GC는 Old영역의 메모리가 임계치 값(IHOP:Initiating Heap Occupancy Percent. 기본 45%)에 도달할 때 까지 계속 되고, Old 영역을 대상으로 한 마킹과정이 이루어지는 중간에도 주기적으로 반복된다.

```
왜 순수한 Young GC는 Concurrent Marking을 하지 않을까? 

Young GC는 비용이 적고 빨리 끝난다. 왜냐하면 Young GC가 일어날 때 보통 90% 이상의 객체들이 죽기 때문이다. 그래서 도달가능성 판단이나, 또다른 영역으로의 Copy 작업이 오래 걸리지 않는다. 반면 Old 영역은 GC가 일어날 때 영역자체도 크고, 객체들이 많이 살아남기 때문에 다른 영역으로 이주하는 비용도 크다. 그래서 Concurrent Marking이나 회수 가치가 큰 Region을 우선적으로 회수하는 방법을 사용해서 Pause Time을 줄인다.
```

### Initial Marking

이 단계는 도달 가능성을 분석하기 위해 루트노드를 열거하는 과정이다. 순수한 Young GC를 할 때도 이 작업을 하기때문에, Initial Marking 단계는 Young GC에 편승되서(piggybacked) 이루어 진다. 그리고 TAMS 포인터 값을 수정해서 Concurrent Mark 동안 새로운 객체들이 가용 공간에 올바르게 할당되도록 한다.

### Concurrent Marking

Initial Marking 단계 이후 Old 영역의 도달 가능성을 분석하는 단계이다. 직접적으로 마킹을 하는 단계이며 사용자 스레드가 동작하는 동안 같이 이루어진다. 시간이 많이 걸리는 작업이고, 이 작업을 하는동안 순수한 Young GC가 일어날 수 있다.

### Remark

Concurrent Marking 단계는 사용자 스레드가 동작하는동안 같이 이루어진다. 따라서 사용자 스레드가 변경시킨 참조들을 반영해서 다시 마킹하는 작업을 해야한다. G1 GC의 경우 이 문제를 해결하기 위해 SATB(Start At The Begining :시작 단계 스냅숏) 방식을 사용한다. 따라서 G1 GC에서 Remark 단계는 사용자 스레드에 의해 끊어진 참조들을 추적해서 재마킹하는 과정이라고 이해하면 된다.

추가적으로 아래 작업들도 이루어진다. 

- 완전히 비어있는 Region을 회수 (Humongous 영역같은 경우)
- 클래스 언로딩 (Method Area 대상 GC)
- Remark 단계와 Clean Up 단계 사이에 회수지역에 대한 우선순위를 정하고 계획을 세운다.

### Clean Up

CleanUp 단계에서는 회수지역에 대한 우선순위와 회수계획을 확정한다. 회수율을 고려해서 Space Reclamation Phase가 필요한지도도 결정한다. 극단적으로 구세대의 모든 객체들이 현재 사용하는 객체라면 Space Reclamation Phase 가 필요가 없을것이다. 추가로 이 단계에서 기억집합 (Remembered Sets)도 정리한다.

### Space Reclamation Phase (Mixed GC)

Young 과 Old 두 영역을 대상으로 Mixed GC를 수행하는 단계이다. Young GC는 하던대로 계속 하는데, Clean Up 단계에서 세운 회수계획을 바탕으로 Old영역에 대한 회수가 추가로 이루어진다.

Old영역을 회수할 때, 마킹된 객체들은 비어있는 Region으로 복사한다. 비어있는 Region으로 복사할 때 메모리에 순차적으로 할당하기 때문에 메모리 단편화문제를 해결할 수 있다. 복사 후 기존 Region은 Freelist에 반납한다.

Mixed GC는 여러 번 반복되며, Old 영역이 충분히 비워지거나 회수 효율이 낮아지면 이 단계가 종료되고 다시 Young Only Phase로 돌아간다.

---

위의 각 단계들은 Concurrent Marking 단계를 제외하곤 전부 사용자 스레드를 정지해야 한다. 하지만 구세대 영역을 마킹하는 작업이 가장 시간이 오래걸리는 과정이기 때문에 이 과정을 백그라운드에서 수행하는 것은 굉장히 메리트가 있다.


---


- GC를 3~4 문장으로 정의한다면?

	- 루트노드(스택프레임 지역변수테이블 등) 로 부터 탐색을 해서, 살아 있는 객체를 찾는다.
	- 살아있는 객체들을 안전한 공간으로 옮긴다.
	- 살아있던 객체들이 있었던, 원래 있던 영역을 반납한다. (쓰레기 객체들은 이 후 덮어쓰기)



궁금한 점

- 논리적 분리, 물리적 분리 이게 뭘 말하는 걸까
	- 핫 스팟 가상머신의 메타스페이스 영역은 JVM 메모리가 아닌 OS힙에 있다고 하는데, 이게 물리적으론 분리되어있지만 논리적으로는 JVM에 있다.

- 카드테이블과 RSet은 다른건가? 카드테이블이 구현방식?

- 증분 업데이트, 시작단계 스냅샷 둘 다 마킹 시작할 때 루트노드 열거의 스냅샷은 유지 하는건가?











 ---

### 좋은자료

- https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html
- https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html
- JVM 밑바닥까지 파헤치기


