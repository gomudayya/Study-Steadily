
G1GC  

- 각각의 과정에 대해서 "아주" 자세하게 설명해보기
- STW가 왜 필요한가? 안하면, 무슨 문제가 생기길래...
- **Freelist**, **Rset**, **Cset**, **write barrier**, **safe point**, **SATB**, **tri-color marking..., TAMS ...**
- 마킹 과정에 대해서 구체적으로 생각해보기



- Young Only Phase

	- 

- 마킹이 끝나는 시점, 끝나고나면 무슨일이 일어나는지 , 남아있는 객체


---
### 기본 용어 

- **Region**
	- G1 GC는 힙메모리를 동일한 크기의 독립된 여러 Region으로 구분한다.
	- 각 리전은 아래 역할중 하나의 역할을 가진다.
		- Free (빈상태, 아직 객체 할당 X, Freelist에서 관리한다.)
		- Eden 
		- Survivor
		- Old
		- Humongous 
			- 큰 객체를 저장한다. 보통 byte[] 또는 char[]
			- 리전 하나의 용량의 절반을 넘기면, 큰 객체이고 연속된 리전에 저장한다.
			- Old Generation으로 취급된다.


- **Freelist**
	- 사용 가능한 빈 region 목록
	- 객체 할당시 Freelist에서 빈 region 선택하고, Eden으로 지정한 후 할당한다.
	- 객체 회수시 Region을 비우고, Freelist에 반환한다.


- **G1 GC**, **Garbage First**
	- G1은 'Garbage First' 를 짧게 줄인 표현이다.
	- G1 GC는 모든 region을 회수하지 않고, 가장 회수 가치가 큰 Region을 먼저 회수한다.
	- 위와 같은 의미에서 Garbage First라고 한다.
		- 클래식 GC들은 신세대 전체, 혹은 구세대 전체, 혹은 힙 전체를 대상으로 회수 했다.
	- G1 GC는 사용자가 설정한 Pause Time 안에 회수 가치가 큰 Region들을 우선적으로 회수한다. 이로 인해 사용자 스레드 정지시간을 예측 가능하게 하고, 짧게 가져갈 수 있다.


- **Cset, CS (Collection Set, 회수 집합)**
	- GC마다 새로 생성된다. 이번 GC에 회수할 것들을 선택한다.
	- G1 GC는 각 region의 회수 가치를 추적해서 CSet을 구성한다.
	- 회수 가치 = 회수 가능한 메모리 크기 / 예상 회수 시간 (경험값)


- **Rset, RS (Remembered Set, 기억 집합)**
	- 외부 Region에서 나를 가르키는 참조들의 목록. (위상정렬 InDegree 개념과 유사)
	- 클래식 GC에서는 세대간 참조를 다룰 때 Young 영역에 대한 RSet이 존재
		- Young GC를 할 때, 구 세대 객체를 전부 스캔하는것을 방지하기 위해
	- G1 GC에서는 모든 Region이 Rset을 가진다. 
		- Rset에 기록된 참조는 GC루트처럼 취급된다.


- **Write Barrier** **(쓰기 장벽)**
	- JVM이 사용자 프로그램이 돌아갈 때 실행하는 짧은 코드
	- object.field = reference 와 같은 형태의 코드가 실행 될 때, Write Barrier가 실행됨.
	- Rset을 업데이트하는데 활용 됨


- **Concurrent Marking**
	- 사용자 스레드와 동시에 실행되며 생존 객체를 표시하는 과정
	- 사용자 스레드 정지시간(Stop-The-World)을 최소한으로 줄이기 위해 사용
	- Initial Mark, Remark 등 일부 단계는 짧은 정지시간 발생


- **SATB (Snapshot At The Beginning, 시작 단계 스냅숏)**
	- 참조 끊긴거에 대한 기록. 
	- 


- **증분 업데이트**


- **Tri-Color Marking** **(삼색 마킹)**
	- 객체 그래프를 탐색 할 때, 흰색, 검은색, 회색 중 하나로 색칠하는 기법
	- 흰색
		- 가비지 컬렉터가 방문한 적 없는 객체.
		- 처음에는 모든 객체가 흰색이며, 탐색이 마친 뒤에도 흰색이면 회수 대상이다.
	- 검은색
		- 가비지 컬렉터가 방문한 적이 있는 객체이다. 확실히 생존함을 의미한다. 
	- 회색
		- 아직 탐색이 진행중인 객체이다.
	- 그림![](https://velog.velcdn.com/images%2Frecordsbeat%2Fpost%2F91db1609-e9e8-462c-8495-a13ce2177d37%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-07-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.44.51.png)
	- 모든 GC는 특정시점에 사용자 스레드를 멈추어야 한다. 
	- 사용자 스레드를 멈추지 않으면 아래 두가지 문제가 생긴다.
		- 회수가 되어야 할 객체를 회수하지 않는다.
			- 이 경우는 다음 GC에 회수되므로 치명적이지 않다.
		- 사용하고 있는 객체를 회수한다.
			- 이 경우는 프로그램 실행에 있어 매우 치명적이다.
	- 사용자 스레드를 멈추어야 하는 시점은 다음 두경우 이다.
		- 루트노드 열거 (GC 루트 목록 수집)
		- 루트노드 열거 이후 객체 그래프를 탐색하는 동안, 참조가 바뀐 것을 반영해야 할 때

- **TAMS**
	- Concurrent Marking 을 하는동안에도 Region 안에 새 객체가 계속 할당 될 수 있다.
	- 어디까지가 Marking 대상인지 구분이 필요하다.
	- TAMS가 그 경계를 표시한다.


- **Safe Point (안전 지점? 안전 영역)**


---

### G1의 동작 과정

1. **최초 표시 (Initial Mark)**

	- GC 루트가 직접 참조하는 객체들을 표시. TAMS 포인터 초기화 
		(루트 노드 열거?, 시작 단계 스냅숏)
	- 이 때는 사용자 스레드를 일시 정지 해야한다.

2. **동시 표시 (Concurrent Mark)**

	- 루트노드로 부터 시작하여 객체의 도달 가능성을 분석 (삼색 마킹 작업)
	- 시간이 좀 걸리지만 사용자 스레드와 동시 수행된다.

3. **재표시 (Re mark)**

	- 동시 표시 단계 동안 참조가 변경된 소수의 객체들을 반영해서 마킹한다.
	- 스냅숏 이후 변경된 소수의 객체만 처리하면 되서 빠르게 끝난다.

4. **복사 및 청소 (Cleanup)**

	- 통계 데이터를 기초로 리전들을 회수 가치와 비용에 따라 정렬한다.
	- 목표한 일시 정지 시간 안에 부합하도록 회수 계획을 세운다. (Cset 구성)
	- 회수할 리전들을 선별하고, 선별된 리전들에서 살아남은 객체들은 빈 리전에 이주한다.
	- 생존 객체를 이동시키고, 생존 객체에 대한 메모리 참조를 변경해야 하므로 사용자 스레드가 잠시 멈추어야 한다.
	- 회수된 리전은 말끔히 비우고, Freelist에 반환한다.


사용자 스레드를 정지해야 하는 단계는 1단계, 3단계, 그리고 4단계 Region 이주할 때 이다. 하지만 가장 시간이 오래걸리는 동시 표시 단계를 사용자 스레드와 동시에 수행하기 때문에 일시정지 시간이 짧다.


---


- GC를 3~4 문장으로 정의한다면?

	- 루트노드(스택프레임 지역변수테이블 등) 로 부터 탐색을 해서, 살아 있는 객체를 찾는다.
	- 살아있는 객체들을 안전한 공간으로 옮긴다.
	- 살아있던 객체들이 있었던, 원래 있던 영역을 반납한다. (쓰레기 객체들은 이 후 덮어쓰기)











 ---
궁금한 점

- 논리적 분리, 물리적 분리 이게 뭘 말하는 걸까
	- 핫 스팟 가상머신의 메타스페이스 영역은 JVM 메모리가 아닌 OS힙에 있다고 하는데, 이게 물리적으론 분리되어있지만 논리적으로는 JVM에 있다.

- 카드테이블과 RSet은 다른건가? 카드테이블이 구현방식?

- 증분 업데이트, 시작단계 스냅샷 둘 다 마킹 시작할 때 루트노드 열거의 스냅샷은 유지 하는건가?



