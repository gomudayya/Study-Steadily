
G1GC  

- 각각의 과정에 대해서 "아주" 자세하게 설명해보기
- STW가 왜 필요한가? 안하면, 무슨 문제가 생기길래...
- **Freelist**, **Rset**, **Cset**, **write barrier**, **safe point**, **SATB**, **tri-color marking..., TAMS ...**
- 마킹 과정에 대해서 구체적으로 생각해보기



- Young Only Phase
- 마킹이 끝나는 시점, 끝나고나면 무슨일이 일어나는지
- 리마크때 남아있는 객체를 처리한다. 무슨객체가 남아있지? 남아있는데 왜 끝낸거야?



---
### 기본 용어 

- **Region**
	- G1 GC는 힙메모리를 동일한 크기의 독립된 여러 Region으로 구분한다.
	- 각 리전은 아래 역할중 하나의 역할을 가진다.
		- Free (빈상태, 아직 객체 할당 X, Freelist에서 관리한다.)
		- Eden 
		- Survivor
		- Old
		- Humongous 
			- 큰 객체를 저장한다. 보통 byte[] 또는 char[]
			- 리전 하나의 용량의 절반을 넘기면, 큰 객체이고 연속된 리전에 저장한다.
			- Old Generation으로 취급된다.


- **Freelist**
	- 사용 가능한 빈 region 목록
	- 객체 할당시 Freelist에서 빈 region 선택하고, Eden으로 지정한 후 할당한다.
	- 객체 회수시 Region을 비우고, Freelist에 반환한다.


- **G1 GC**, **Garbage First**
	- G1은 'Garbage First' 를 짧게 줄인 표현이다.
	- G1 GC는 모든 region을 회수하지 않고, 가장 회수 가치가 큰 Region을 먼저 회수한다.
	- 위와 같은 의미에서 Garbage First라고 한다.
		- 클래식 GC들은 신세대 전체, 혹은 구세대 전체, 혹은 힙 전체를 대상으로 회수 했다.
	- G1 GC는 사용자가 설정한 Pause Time 안에 회수 가치가 큰 Region들을 우선적으로 회수한다. 이로 인해 사용자 스레드 정지시간을 예측 가능하게 하고, 짧게 가져갈 수 있다.


- **Cset, CS (Collection Set, 회수 집합)**
	- GC마다 새로 생성된다. 이번 GC에 회수할 것들을 선택한다.
	- G1 GC는 각 region의 회수 가치를 추적해서 CSet을 구성한다.
	- 회수 가치 = 회수 가능한 메모리 크기 / 예상 회수 시간 (경험값)


- **Rset, RS (Remembered Set, 기억 집합)**
	- 외부 Region에서 나를 가르키는 참조들의 목록. (위상정렬 InDegree 개념과 유사)
	- 클래식 GC에서는 세대간 참조를 다룰 때 Young 영역에 대한 RSet이 존재
		- Young GC를 할 때, 구 세대 객체를 전부 스캔하는것을 방지하기 위해
	- G1 GC에서는 모든 Region이 Rset을 가진다. 
		- Rset에 기록된 참조는 GC루트처럼 취급된다.


- **Write Barrier** **(쓰기 장벽)**
	- JVM이 사용자 프로그램이 돌아갈 때 실행하는 짧은 코드
	- object.field = reference 와 같은 형태의 코드(참조변경)가 실행 될 때, Write Barrier가 실행됨. (Low-Level의 AOP에 비유된다.)
	- 객체간 참조 변경을 추적하기위한 코드이다.
	- Rset을 업데이트하는데 활용하고, 뒤에 나오는 SATB나 증분업데이트에서도 활용된다.


- **루트노드 열거**
	- GC 시작 시 모든 GC Root를 찾아내는 과정
		- 스택의 지역변수, 혹은 클래스의 적정변수 등
	- 사용자 스레드를 반드시 중단시켜야 한다. (STW)


- **Concurrent Marking**
	- 사용자 스레드와 동시에 실행되며 생존 객체를 표시(Marking)하는 과정
	- 사용자 스레드 정지시간(Stop-The-World)을 최소한으로 줄이기 위해 사용한다.


- **Tri-Color Marking** **(삼색 마킹)**
	- 객체 그래프를 탐색 할 때, 흰색, 검은색, 회색 중 하나로 색칠하는 기법
	- 객체 그래프 탐색은 스택을 이용한 DFS알고리즘으로 이루어진다.
	- 흰색
		- 가비지 컬렉터가 방문한 적 없는 객체.
		- 처음에는 모든 객체가 흰색이며, 탐색이 마친 뒤에도 흰색이면 회수 대상이다.
	- 검은색
		- 가비지 컬렉터가 방문한 적이 있는 객체이다. 확실히 생존함을 의미한다.
		- 스택에서 꺼내어지고, 자신의 '직속 자식'까지 확인해서 스택에 넣으면 검정색으로 표시한다.
	- 회색
		- 아직 탐색이 진행중인 객체이다.
		- 이전 노드를 통해 방문은 한 번 했지만, 아직 스택 안에 있고, 꺼내지지 않은 객체

	- **삼색마킹의 문제점. 왜 SATB와 증분업데이트 같은 동기화 기법이 필요한가?**![](https://velog.velcdn.com/images%2Frecordsbeat%2Fpost%2F91db1609-e9e8-462c-8495-a13ce2177d37%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-07-15%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.44.51.png)
	- 위의 그림은 ConcurrentMarking Phase를 삼색마킹으로 표현한 그림이다.
		- 빨간색 화살표는 사용자 스레드에 의해 객체 참조가 끊긴 부분이다.
		- 녹색 화살표는 사용자 스레드에 의해 객체 참조가 추가된 부분이다.
	- 문제
		- 5시 방향의 흰색 노드는 사용자 스레드에 의해 객체 참조가 끊겨 마킹이 될 수 없다.
		- 그런데 이미 마킹이 완료된 검정 객체에 의해 객체참조가 추가되었다.
		- 현재 마킹상태만 보면 흰색 노드 2개는 회수 대상이다. 하지만 사용자 스레드에 의해 참조가 추가되었기 때문에 분명히 사용하는 객체이다.
		- 사용하는 객체를 회수하면 프로그램상의 매우 치명적인 문제가 발생하게 된다.
			- 사용하지 않는 객체를 회수하지 않는 것(Floating Garbage)은 어차피 다음 GC에서 회수되기 때문에 치명적이지 않다. 하지만 사용하는 객체를 회수하는 것은 절대 안된다.

	- 해결방안 (둘 중 하나만 사용해도 해결할 수 있다)
		- **SATB** (G1,셰넌도어)
		- **증분업데이트** (CMS)


- **SATB (Snapshot At The Beginning, 시작 단계 스냅숏)**
	- Concurrent Marking 기간 동안 '참조가 끊겼을 때' 끊긴 참조 정보를 기록한다. 
	- 참조의 변경을 추적할 때는 Write Barrier를 이용한다.
	- Concurrent Marking 이 종료되면 사용자 스레드를 중지시킨 후 참조가 끊겨서 탐색이 안되었던 부분을 마킹한다.
	- 참조가 끊긴 부분들이 다시 사용되지 않기 때문에 Floating Garbage가 많이 생길 수 있다.


- **증분 업데이트 (Incremental Update)**
	- Concurrent Marking 기간 동안 '참조가 추가되었을 때' 추가된 참조 정보를 기록한다.
		- 정확히 하면 검은색 노드에서 흰색 노드로의 참조 추가가 생길때이다.
	- SATB와 마찬가지로 Write Barrier를 이용한다.
	- Concurrent Marking 이 종료되면 사용자 스레드를 중지시킨 후 참조가 추가된 객체들을 마킹한다.
	- 검은색 노드에서 흰색노드로의 추가가 생길때 참조 정보를 기록하므로, 이 조건을 판단하는 로직때문에 Write Barrier 비용이 커질 수 있다.


- **TAMS**
	- Concurrent Marking 을 하는동안에도 Region 안에 새 객체가 계속 할당 될 수 있다.
	- 어디까지가 마킹 대상인지 구분이 필요하다.
	- TAMS가 그 경계를 표시한다.
		- 새로운 객체들은 TAMS 포인터보다 높은 주소 영역에 할당되고, 생성된지 얼마 안되었으니, 사용중이라고 간주한다.


- **Safe Point (안전 지점? 안전 영역)**


---

### G1의 동작 과정

1. **최초 표시 (Initial Mark)**

	- GC 루트가 직접 참조하는 객체들을 표시. TAMS 포인터 초기화 
		(루트 노드 열거?, 시작 단계 스냅숏)
	- 이 때는 사용자 스레드를 일시 정지 해야한다.

2. **동시 표시 (Concurrent Mark)**

	- 루트노드로 부터 시작하여 객체의 도달 가능성을 분석 (삼색 마킹 작업)
	- 시간이 좀 걸리지만 사용자 스레드와 동시 수행된다.

3. **재표시 (Re mark)**

	- 동시 표시 단계 동안 참조가 변경된 소수의 객체들을 반영해서 마킹한다.
	- 스냅숏 이후 변경된 소수의 객체만 처리하면 되서 빠르게 끝난다.

4. **복사 및 청소 (Cleanup)**

	- 통계 데이터를 기초로 리전들을 회수 가치와 비용에 따라 정렬한다.
	- 목표한 일시 정지 시간 안에 부합하도록 회수 계획을 세운다. (Cset 구성)
	- 회수할 리전들을 선별하고, 선별된 리전들에서 살아남은 객체들은 빈 리전에 이주한다.
	- 생존 객체를 이동시키고, 생존 객체에 대한 메모리 참조를 변경해야 하므로 사용자 스레드가 잠시 멈추어야 한다.
	- 회수된 리전은 말끔히 비우고, Freelist에 반환한다.


사용자 스레드를 정지해야 하는 단계는 1단계, 3단계, 그리고 4단계 Region 이주할 때 이다. 하지만 가장 시간이 오래걸리는 동시 표시 단계를 사용자 스레드와 동시에 수행하기 때문에 일시정지 시간이 짧다.


---


- GC를 3~4 문장으로 정의한다면?

	- 루트노드(스택프레임 지역변수테이블 등) 로 부터 탐색을 해서, 살아 있는 객체를 찾는다.
	- 살아있는 객체들을 안전한 공간으로 옮긴다.
	- 살아있던 객체들이 있었던, 원래 있던 영역을 반납한다. (쓰레기 객체들은 이 후 덮어쓰기)











 ---
궁금한 점

- 논리적 분리, 물리적 분리 이게 뭘 말하는 걸까
	- 핫 스팟 가상머신의 메타스페이스 영역은 JVM 메모리가 아닌 OS힙에 있다고 하는데, 이게 물리적으론 분리되어있지만 논리적으로는 JVM에 있다.

- 카드테이블과 RSet은 다른건가? 카드테이블이 구현방식?

- 증분 업데이트, 시작단계 스냅샷 둘 다 마킹 시작할 때 루트노드 열거의 스냅샷은 유지 하는건가?



