
```java
// JVM 어떤 구성 요소를 가지고 있는지 
// JVM이 메모리를 어떤 식으로 구분하고 있는지 
// class A는 어떤 식으로 로드되는지에 대해서 
// classloader란? 

class A { 
	private static final String STR = "ABC";
	private static Long l = Long.valueOf(-1L); 
	private static int i = -1; 
	private static C c = new C(); 
	private final String a = "ABC"; 
	private final int ii = 1; 
	private C cc = new C(); 
	
	public static void main(...) { 
		// JVM Memory에서 무슨 일이 일어나는지 설명해 봅시다. 
		A a = new A(); 
		B b = new B(); 
	}
	
} 

class B extends A { 
	// ... 
} 
		
class C { 
	// ... 
}

```

### 내 망상 내 생각

- 클래스 정보를 저장하는 곳이 있을 것 같다.
	- JVM이 처음 로드 된다면 그 곳에 모든 클래스의 메타 정보를 저장하고, 객체를 생성할 때 그 정보를 토대로 생성하지 않을까
		**=> 처음에 모든 메타정보를 저장하는 것이 아니라, 클래스 로더가 Lazy하게 로드한다.**
	- 구체적으로 생각한다면 클래스의 프로퍼티, 메서드 시그니처, 그리고 필드 초기화하는 정보도 같이 관리할 것 같음

- 메인 메서드가 실행될 때
	- 일단 메인 메서드는 스택 영역에서 호출 될 것
	- new A() 도 결국 생성자 함수이고, 스택에 쌓일 것 같다.
		- 왜 프로그래밍 언어는 힙과 스택을 구분할까?
			=>**담기는 데이터의 성격이 다르다. 스택의 데이터는 순차적이지만, 힙은 랜덤이다**
	- 우선 힙 메모리에 빈 공간이 있다면 객체의 정보(프로퍼티, 타입)을 저장한다.
		- `private static final String STR = "ABC";` 
			- 스태틱 변수는 굳이 별도 공간에 저장할 필요가 없어 보인다. 이건 클래스 정보에 넣어도 문제 없지 않을까?
	- 객체의 정보를 저장한 공간을 가리키는 참조 주소를 할당한다.
	- 메인 스택에 'a' 라는 변수를 만들고, 참조 주소의 값을 저장한다.


---

### JVM 구성요소

<자바 가상 머신 명세> 가 특정 방식을 강제하지 않는 부분들은 JVM마다 각각의 경계가 와 구현 방식이 다를 수 있음

- 클래스 로더
	- 로딩 (부트스트랩 클래스 로더, 사용자 정의 클래스 로더 사용)

		- 경로가 포함된 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다.
		- 바이너리 바이트 스트림으로 표현된 정적인 구조를 메서드 에어리어에서 사용하는 런타임 데이터 구조로 변환한다. 
			- 필드 정보, 메서드 정보, 런타임 상수풀 (리터럴, 심볼), static 변수 공간 등
		- 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성한다. 
		 (리플렉션 용도, Method Area 참조)

	- 링킹 (검증, 준비, 해석)

		- 검증

			- 클래스 파일의 바이트 스트림에 담긴 정보가 <자바 가상 머신 명세>에서 규정한 모든 제약을 만족하는지 확인한다.
			- 코드로 변환해 실행했을 때 자바 가상 머신 자체의 보안을 위협하지 않는지 확인한다.
			- 클래스 파일이 꼭 자바 소스코드로 부터 컴파일 되는 것은 아니다. 바이너리 편집기로 직접 타이핑해서 만들 수 있기 때문에, 이러한 검증 절차는 꼭 필요하다.
			- 파일형식 검증, 메타데이터 검증, 바이트 코드 검증, 심벌 참조 검증 등을 한다.
		
		- 준비

			- static 변수를 메모리에 할당하고, 초깃값을 설정하는 단계
			- 준비 단계에서 할당하는 초깃값은, 해당 데이터 타입의 제로값이다.
				- int = 0, 참조 = null 등
				- 단 ConstantValue 속성 (final)이 존재한다면 해당 속성이 지정한 값을 할당

		- 해석

			- 심볼참조와 직접참조의 개념을 알 필요가 있다.
			- 심볼참조
				- 클래스파일에 있는 리터럴과 심볼을 런타임 상수풀 인덱스와 엮어서 저장
			- 직접참조
				- 런타임 상수풀 인덱스가 가르키는 심볼의 메타정보가 어디에 저장되어있는지 그 주소를 저장한다. (Method Area 안의 주소)
				- Method Area 안에 없다면, 해당 심볼을 클래스로더가 초기화한다.
			- 해석 단계는 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다.
			- JVM 명세는 해석 단계를 수행하는 시간을 특정하지 않고, 심벌 참조를 다루는 바이트코드 명령어에 대해 실행하도록 규정했다. 따라서 '로딩' 단계에서 심벌 참조를 바로 해석할지, 또는 실제로 사용될 때 해석할지는 JVM이 결정한다.

	- 초기화

		- '준비' 단계에서 할당한 초깃값을 코드에 기술된 대로 다시 초기화 한다.
		- 필드 초기화, 스태틱 블록 초기화


- 런타임 데이터 영역 

	JVM 컨텍스트    : 힙, 메소드 에어리어, 런타임 상수풀.   모든 쓰레드가 공유하는 영역
	쓰레드 컨텍스트 : PC 레지스터, JVM 스택, 네이티브 메서드 스택

	- PC 레지스터 (PC 카운터) 

		- 바이트코드 줄 번호 표시기 (명령어)
		- 인터프리터와 상호작용 하며 프로그램을 실행

	- JVM 스택

		- 메서드가 호출 될 때마다 스택 프레임을 만든다. 만들어진 스택 프레임을 JVM 스택에 PUSH하고, 메서드가 종료되면 POP한다.
			- 스택 프레임은 **지역변수 테이블**, 피연산자 스택, 동적 링크, 메서드 반환 값 등의 정보를 저장한다.
			- 지역변수 테이블에 할당받을 공간은 컴파일 시점에 완벽하게 정해져 있고, 메서드 실행중에 절대 변하지 않는다.
	
	- 네이티브 메서드 스택

		- JVM 스택과 유사하다. 다만 네이티브 메서드를 실행할 때 사용된다.
			- 네이티브 메서드 : C/C++로 작성된 메서드, OS종속적, 플랫폼마다 다르게 구현되어져 있음
	
		- JVM 명세에 어떤식으로 구현할지 명시되어 있지 않다. 따라서 구현자가 자유롭게 구현할 수 있다.

	- 힙

		- 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리
		- 모든 객체 인스턴스와 배열은 힙에 할당된다
		- GC가 관리하는 메모리 영역
			- 세대별 컬렉션 이론을 사용하는 GC는 에덴, 신세대, 구세대, 서바이버 등으로 나누기도 한다.
		- 객체 할당 효율을 높이기 위해 *스레드 로컬 할당 버퍼(?)* 여러개로 나뉜다
		- 자바 힙은 물리적으로 떨어진 메모리에 위치해도 좋으나 논리적으로는 연속적이어야 한다.
		- -Xms 매개변수를 사용해서 힙 크기를 설정할 수 있다. (초기 힙, 최대 힙)

	- 메소드 에어리어 

		- **타입 정보**, **정적 변수**, **JIT 컴파일러가 컴파일한 코드 캐시** 등을 저장한다. 
		- 대부분의 데이터들이 회수 대상이 거의 되지 않고, 회수가 드물게 일어남.
		- 내부에 런타임 상수 풀이라는 공간이 있다.
			- 컴파일 타임에 생성된 리터럴, 심벌참조와 이에 매칭되는 상수 풀 인덱스를 저장한다.
			- 자바 클래스파일은 위의 정보를 반드시 포함시켜야 한다.
			- 나중에 PC와 인터프리터가 효율적으로 상호작용하게끔 해준다. (압축 관점)

	- 다이렉트 메모리

		- JVM 명세에는 존재하지 않음. JVM 런타임 영역에도 속하지 않음
		- OS힙이라고 생각하면 된다.
		- NIO는 JVM힙이 아닌 네이티브 힙(OS힙) 에 메모리를 직접 할당하는 네이티브 함수 라이브러리를 사용한다. 이 때 DirectByteBuffer 객체를 통해 작업을 수행한다. 자바 힙 <-> 네이티브힙 사이에 데이터를 복사해 주고받지 않고, 다이렉트로 전달하는 방법으로 성능을 개선했다.
		- JVM 런타임 영역에 속하지 않지만, 자주 쓰이는 메모리이며 OutOfMemory의 원인이 될 수 있어 관리 대상이다.


- 실행 엔진 

	- JIT 컴파일러
	- 인터프리터
	- GC

- 네이티브 인터페이스

	- 자바에서 불가능한 OS접근 로직들을 실행




![jvm-memory](https://blog.kakaocdn.net/dna/bmmGcd/btrIFHKUbDl/AAAAAAAAAAAAAAAAAAAAABGeCXO_d4CzmOeRJdcBGMlhQxXR8P8dYy7H5u8xIkbj/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=I8Nzq%2FgPbU2xHHg1rpoltrMv1r8%3D)


![jvm-Runtime Data Area](https://blog.kakaocdn.net/dna/brvkNA/btrIPYdYwMf/AAAAAAAAAAAAAAAAAAAAACbarCLotN-ID77EuRsRxAHcYFNnmzyi3WGw-VCOmJvW/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=OeKr%2FzfM1%2BbUp5GNoWMlXxlwTOk%3D)

---

### 설명

```java
// JVM 어떤 구성 요소를 가지고 있는지 
// JVM이 메모리를 어떤 식으로 구분하고 있는지 
// class A는 어떤 식으로 로드되는지에 대해서 
// classloader란? 

class A { 
	// 각 필드에 따른 클래스로더의 로딩과정 차이

	// [static final = 바로할당 필요? 따라서 준비단계에서 클래스로더가 String 초기화] 
	private static final String STR = "ABC";
	
	// [준비단계에서 null, 초기화 단계에서 값을 할당하려 할 때 클래스로더가 Long 초기화]
	private static Long l = Long.valueOf(-1L); 
	
	// [준비단계에서 0, primitive 해석 불필요]
	private static int i = -1;
	
	// [준비단계에서 null, 초기화 단계에서 해석 필요, 변수 c가 MethodArea에서 힙을 가르킴]
	private static C c = new C(); // C를 로드하는 동안, 나머지A의 로드작업을 멈춤
	
	// [인스턴스 변수는 클래스 로더 초기화때 결정되지 않음. 얘네가 헷갈리네 힙에 저장할듯?]
	// [필드 초기화도 결국 생성자로 있는 코드로 컴파일되서, 힙에 저장해야 한다고 하네...]
	
	private final String a = "ABC"; 
	private final int ii = 1; 
	
	// [이건 위의 static 변수가 없었다면, A의 인스턴스 생성 시점에 레이지하게 해석 했을듯?]
	// [하지만 위의 static 변수가 있어서 이미 해석되어 있음]
	private C cc = new C(); 
	
	public static void main(...) { 
		// JVM Memory에서 무슨 일이 일어나는지 설명해 봅시다. 
		// 1. 메인메서드가 있는 클래스(A)를 클래스로더가 초기화 함 아래 상세 설명(1 ~ 2.5)
		// 2. JVM 스택에서 스택프레임 생성
		// 3. PC 카운터가 바이트코드를 가르키며 인터프리터와 상호작용하며 코드 실행
		// 4. new A()되는 시점에 A는 이미 '해석' 절차가 완료되어 있음. 
		//    Method Area의 정보를 토대로 인스턴스 생성, 힙에 저장, 지역변수 a가 가르킴
		// 5. new B()가 일어나는 시점에 B클래스의 해석이 필요. 클래스로더가 B클래스를 초기화
		//    이 때, extends 키워드를 확인하고, A클래스가 Method Area에 있는지 확인함.
		
		A a = new A(); 
		B b = new B(); 
	} 
	
} 

class B extends A { 
	// ... 
} 
		
class C { 
	// ... 
}


1. JVM은 구동직후 main 메서드를 포함하는 클래스를 찾아 실행한다. 이 때, 메인타입의 클래스로더가 초기화(로딩, 링킹, 초기화)를 진행한다.

2. 클래스로더가 초기화 하는 과정

2-1. 로딩
   클래스파일 (바이트 스트림) 을 읽고, 메서드 에어리어에 데이터를 로드한다.
   - 클래스의 필드정보, 메서드 정보, static 변수 공간, 런타임 상수풀 정보를 로드한다.
     - 런타임 상수풀 (심볼과 리터럴을, 런타임 상수풀 인덱스와 엮어서 저장)
       
2-2. 링킹(검증)

	- 바이트코드가 JVM 명세의 제약을 만족하는지, JVM 보안에 위협이 되는 것은 없는지 검증한다.

2-3. 준비

	- static 변수의 메모리 공간을 할당하고 제로값을 넣는다. (int = 0, reference = null)
	- 단 static final 의 경우에는 코드에 있는 값을 사용한다.
	  
2-4. 해석

	- 런타임 상수풀의 심볼참조를 직접참조로 대체하는 과정이다. 
	- 런타임 상수풀의 인덱스가 가르키는 심볼을 실제 Method Area의 메타정보가 저장되어 있는       곳으로 가리키게 한다. 이 때 없으면 해당 심볼을 초기화한다.
	  
2.5. 초기화

	- '준비' 과정에서 제로값으로 초기화 했던 값들을 실제 작성된 코드값으로 초기화한다.
	- 스태틱 블록을 초기화한다.
	  
```


---

쓰레드 로컬 할당 버퍼

