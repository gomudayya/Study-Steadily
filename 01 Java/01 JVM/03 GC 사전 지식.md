
### 도달 가능성 (reachability analysis) 알고리즘

- **GC루트**를 시작 노드로 하여, 탐색한다. 
- 탐색 과정에서 만들어지는 경로를 참조 체인이라고 한다.
- 어떤 객체와 GC루트 사이를 이어 주는 참조 체인이 없다면, 도달 불가능한 객체로 회수 대상이 된다.
- GC 공부할 때, 자주 등장하는 용어이니 알아 놓자. 일종의 그래프 탐색으로 이해하면 될 것 같다. 대부분의 주류 프로그래밍 언어들이 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다. 

**GC루트**로 이용할 수 있는 객체는 아래와 같다.
(GC루트는 객체와 참조 변수를 둘 다 혼용하는 느낌이다.)

- 스택 프레임의 지역 변수 테이블에서 참조하는 객체
	- 메서드에서 쓰는 매개변수, 지역변수
- 메서드 영역의 정적 필드로 참조하는 객체
- 메서드 영역의 상수로 참조되는 객체 : 문자열 풀
	- 문자열 객체도 내부적으로 byte[] 배열을 가르키므로, GC 루트로 쓰일 수 있다.

추가로 더 있지만 주요 GC루트는 위와 같다.

### 세대 단위 컬렉션 이론

- 현재 상용 가상 머신들 대부분은 세대 단위 컬렉션 이론에 기초해 설계되었다.
- Young Generation, Old Generation 을 구분한다.

이렇게 세대 구분을 하게 된 이유는 아래 가설이 경험적으로 관측되었기 때문이다.

1. 대다수의 객체는 일찍 죽는다. (약한 세대 가설)
2. 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
	(강한 세대 가설)

일찍 죽을 것이라고 예측되는 객체들을 분리해 가비지컬렉션 빈도를 높이고, 
오래 살 가능성이 높은 객체들을 분리해서 가비지컬렉션 빈도를 줄이는 식으로 효율을 높인다.

**이 때, 구세대에서 신세대를 참조하는 상황은 어떻게 다루어야 할까?**

도달 가능성 이론과 같이 구체적으로 생각해보자. GC가 수행 되면, 스택 프레임의 지역변수 테이블을 확인하고, 지역변수의 주소를 바탕으로 신세대에 속하는지, 구세대에 속하는지 알 수 있다. 이 변수들을 GC루트로 사용하게 되는데, 구세대에서 신세대를 참조하는 상황을 고려한다면 신세대 GC루트는 물론이고, 구세대 GC루트로부터 까지 탐색을 해야만 한다. 이는 성능적으로 부담이 크다. 그래서 이러한 이유로 세 번째 경험 법칙이 추가된다. 

- 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다 (세대 간 참조 가설)

참조 관계의 두 객체는 생애주기를 함께하는 경향이 있다. 그러므로 구세대에서 참조하는 신세대 객체는 잘 죽지 않을 것이고, 신세대 객체는 구세대로 승격 된다. 이러한 결과로 위의 가설이 성립하게 되고, 매 번 구세대 전체를 훑는 건 낭비가 된다.

## 가비지 컬렉션 알고리즘

**마크-스윕** 알고리즘, **마크-카피** 알고리즘, **마크-컴팩트** 알고리즘이 있다. **3가지 모두 장단점이 있고, 중요하다.**

### 마크-스윕 알고리즘

- 방식
	- 루트 노드에서 탐색하며 살릴 객체를 표시, 이후 표시 없는 객체 회수
- 단점
	- 객체 대부분이 회수 대상이라면 표시하기 힘들다.
	- 메모리 파편화가 심하다. 가비지 컬렉터가 쓸고 간 자리에 메모리 파편이 생긴다.

### 마크-카피 알고리즘

- 방식
	- 가용 메모리를 두 블록으로 나눠서, 한 번에 한 블록만 사용한다. 
	- 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사 하고, 기존 블록은 반납한다.
- 장점
	- 메모리 파편화 문제를 해결할 수 있다.
- 단점
	- 가용 메모리를 한 블록만 사용하기 때문에 공간 낭비가 심하다.
	- 객체의 생존율이 높을수록 복사할 게 많아져 효율이 나빠진다.


오늘 날 대부분의 JVM은 신세대에 이 알고리즘을 적용한다. IBM의 연구에 따르면 신세대 객체 중 98%가 첫 번째 가비지 컬렉션에서 살아남지 못한다고 한다. 이와 같은 이유로 마크-카피 알고리즘을 사용하되, 신세대용 메모리 영역을 1:1로 나누지 않는다.

마크-카피 알고리즘의 일종인 '아펠 스타일 컬렉션' 방식은 신세대영역을 에덴 하나와 서바이버 두개로 나눈다. (에덴: 80%, 서바이버1 : 10%, 서바이버2 : 10%)
그리고 메모리를 할당할 때는 에덴공간과 서바이버중 하나만 사용한다. 가비지 컬렉션이 시작되면 살아남은 객체를 나머지 서바이버 공간으로 복사한다. 그리고 에덴과 이전 생존자 공간을 곧바로 비운다.

이렇게 하면 메모리 파편화 문제를 해결할 수 있다. 하지만 만약 신세대 객체 중 20%가 살아남았다면 어떻게 될까? 이 때는 다른 서바이버 공간에 살아남은 객체를 다 넣을수가 없다. 따라서 구세대 영역으로 옮겨지 게 된다. (메모리 할당 보증) 

### 마크 - 컴팩트 알고리즘

- 방식
	- 살아있는 객체를 마킹하고, 생존한 객체를 메모리 한쪽 끝으로 모은다.
	- 그리고 나머지 공간은 한꺼번에 반납한다. (사용 가능 처리)
- 장점
	- 메모리 파편화 문제를 해결할 수 있다.
	- 마크-카피의 문제점을 극복할 수 있다.
		- 마크-카피 는 객체 생존율이 높다면 복사할 게 많아져 효율이 나빠진다. 
		- 메모리 보증공간을 더 많이 마련해야 하기 때문에
		- 따라서 마크-컴팩트는 객체 생존율이 높은 구세대 영역에 적합한 알고리즘이다.
- 단점
	- 메모리를 한쪽 끝으로 모으는 과정에서 객체를 가리키던 기존참조를 갱신하는 작업은 부담이 크다. 특히나 구세대라면 살아있는 객체가 많기 때문에 더욱 그렇다.
	- CMS의 경우 마크-스윕을 기본으로 하고, 메모리 파편화가 심해지면 마크-컴팩트를 사용한다.