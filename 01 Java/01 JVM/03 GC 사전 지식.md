
### 도달 가능성 (reachability analysis) 알고리즘

- **GC루트**를 시작 노드로 하여, 탐색한다. 
- 탐색 과정에서 만들어지는 경로를 참조 체인이라고 한다.
- 어떤 객체와 GC루트 사이를 이어 주는 참조 체인이 없다면, 도달 불가능한 객체로 회수 대상이 된다.
- GC 공부할 때, 자주 등장하는 용어이니 알아 놓자. 일종의 그래프 탐색으로 이해하면 될 것 같다. 대부분의 주류 프로그래밍 언어들이 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다. 

**GC루트**로 이용할 수 있는 객체는 아래와 같다.
(GC루트는 객체와 참조 변수를 둘 다 혼용하는 느낌이다.)

- 스택 프레임의 지역 변수 테이블에서 참조하는 객체
	- 메서드에서 쓰는 매개변수, 지역변수
- 메서드 영역의 정적 필드로 참조하는 객체
- 메서드 영역의 상수로 참조되는 객체 : 문자열 풀
	- 문자열 객체도 내부적으로 byte[] 배열을 가르키므로, GC 루트로 쓰일 수 있다.

추가로 더 있지만 주요 GC루트는 위와 같다.

### 세대 단위 컬렉션 이론

- 현재 상용 가상 머신들 대부분은 세대 단위 컬렉션 이론에 기초해 설계되었다.
- Young Generation, Old Generation 을 구분한다.

이렇게 세대 구분을 하게 된 이유는 아래 가설이 경험적으로 관측되었기 때문이다.

1. 대다수의 객체는 일찍 죽는다. (약한 세대 가설)
2. 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
	(강한 세대 가설)

일찍 죽을 것이라고 예측되는 객체들을 분리해 가비지컬렉션 빈도를 높이고, 
오래 살 가능성이 높은 객체들을 분리해서 가비지컬렉션 빈도를 줄이는 식으로 효율을 높인다.

**이 때, 구세대에서 신세대를 참조하는 상황은 어떻게 다루어야 할까?**

도달 가능성 이론과 같이 구체적으로 생각해보자. GC가 수행 되면, 스택 프레임의 지역변수 테이블을 확인하고, 지역변수의 주소를 바탕으로 신세대에 속하는지, 구세대에 속하는지 알 수 있다. 이 변수들을 GC루트로 사용하게 되는데, 구세대에서 신세대를 참조하는 상황을 고려한다면 신세대 GC루트는 물론이고, 구세대 GC루트로부터 까지 탐색을 해야만 한다. 이는 성능적으로 부담이 크다. 그래서 이러한 이유로 세 번째 경험 법칙이 추가된다. 

- 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다 (세대 간 참조 가설)

참조 관계의 두 객체는 생애주기를 함께하는 경향이 있다. 그러므로 구세대에서 참조하는 신세대 객체는 잘 죽지 않을 것이고, 신세대 객체는 구세대로 승격 된다. 이러한 결과로 위의 가설이 성립하게 되고, 구세대 전체를 훑는 건 낭비가 된다.


## 가비지 컬렉션 알고리즘


